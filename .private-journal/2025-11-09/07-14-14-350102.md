---
title: "7:14:14 AM - November 9, 2025"
date: 2025-11-09T12:14:14.350Z
timestamp: 1762690454350
---

## Project Notes

## Homelab Media Pipeline & IaC Implementation - Complete Session

### Session Overview
Created comprehensive plans for two major initiatives:
1. **Media Pipeline**: Blu-ray ripping â†’ transcoding workflow
2. **Infrastructure as Code**: Terraform + Ansible for entire homelab

### Media Pipeline Architecture (Finalized)

**Decision: Hybrid Privileged Approach**
- Both ripper and transcoder containers will be privileged
- Unified media user: UID/GID 1000 across host and all containers
- No complex idmap configuration needed
- Trade-off: Simplicity and maintainability over container isolation security

**Container Setup:**
- **Ripper**: MakeMKV with optical drive passthrough (/dev/sr0, /dev/sg*)
- **Transcoder**: ffmpeg/HandBrake with Intel Arc GPU passthrough
- **Storage**: Host MergerFS at /mnt/storage, bind mounted to containers

**Key Challenge Resolved:**
Initial unprivileged container had persistent write permission issues with mergerfs despite:
- Correct UID/GID mapping
- Proper group membership
- Group-writable permissions
- Fresh login shells

Root cause likely: mergerfs + unprivileged container interaction complexity.
Solution: Migrate to privileged containers (simpler, more reliable for homelab).

**Working Transcoding Command:**
```bash
ffmpeg -i INPUT.mkv \
  -map 0:v:0 \
  -map 0:a:m:language:eng \
  -map 0:a:m:language:bul? \
  -map 0:s:m:language:eng? \
  -map 0:s:m:language:bul? \
  -c:v libx265 \
  -preset slow \
  -crf 18 \
  -c:a copy \
  -c:s copy \
  OUTPUT.mkv
```

Keeps all English audio/subs, Bulgarian if present, preserves original audio formats.

### IaC Strategy (Comprehensive)

**Technology Stack:**
- **Terraform** with BPG provider (NOT Telmate - unmaintained)
- **Ansible** for configuration management
- **Ansible Vault** for secrets
- **Git** for version control

**Implementation Timeline (8 weeks):**
1. Weeks 1-2: Foundation (tools, Git, secrets management)
2. Weeks 3-4: Test container from scratch (learn workflow)
3. Weeks 5-6: Import production containers (ripper, transcoder)
4. Weeks 7-8: Automate host configuration (MergerFS, GPU drivers)
5. Ongoing: Polish, DR testing, monitoring

**Key Insight: Start with New Container**
Don't immediately import production. Build test container first to:
- Learn Terraform plan/apply/destroy cycle
- Understand Ansible roles and playbooks
- Make mistakes in safe environment
- Gain confidence before touching production

**Critical Limitations Accepted:**
- LXC doesn't support cloud-init (use Ansible instead)
- Device passthrough requires Ansible (Terraform can't set cgroup rules)
- Some host config stays manual (initial Proxmox setup, hardware changes)
- Privileged containers needed for optical drive reliability

**Disaster Recovery Approach:**
- Backup Terraform state after every apply
- Encrypt secrets with Ansible Vault
- Push code to Git remote
- Standard Proxmox container backups
- MergerFS data backups (separate strategy)

RTO: <1 hour for infrastructure, longer for data restoration.

### File Artifacts Created

1. **transcoding-container-setup.md** - Initial manual setup documentation
2. **homelab-media-pipeline-plan.md** - Complete privileged container approach
3. **homelab-iac-strategy.md** - 8-week IaC implementation plan

All three documents are comprehensive, ready for Peter to execute in future session.

### Next Session Actions

**For Media Pipeline:**
1. Create media user (UID 1000) on Proxmox host
2. Destroy current unprivileged transcoder container
3. Create new privileged transcoder following plan
4. Create privileged ripper container
5. Test full workflow end-to-end

**For IaC:**
1. Install Terraform and Ansible on Mac
2. Create Git repository structure
3. Set up Ansible Vault
4. Create Proxmox API token
5. Begin Phase 1 foundation work

### Research Findings

**Community Scripts Analysis:**
- Tdarr, Jellyfin, Plex default to unprivileged containers
- GPU passthrough works unprivileged BUT requires complex idmap
- No MakeMKV or HandBrake scripts exist (manual installation needed)
- Scripts handle app installation, NOT storage or device passthrough
- Standard pattern: Dynamic GID extraction and /etc/group sync

**Privileged vs Unprivileged Reality:**
- Unprivileged is security best practice
- GPU passthrough: Works in both (unprivileged more complex)
- Optical drive passthrough: Extremely difficult unprivileged (privileged recommended)
- For homelab with network isolation: Privileged is pragmatic choice

**Terraform Provider Landscape:**
- BPG provider: Actively maintained, comprehensive, works with Proxmox 8+
- Telmate provider: AVOID - unmaintained, buggy, limited features
- Import functionality allows gradual adoption without destroying existing setup

### Lessons for Future Containers

**Networking Fix Required:**
Every new container needs network interface brought up manually:
```bash
pct enter <CTID>
ip link set eth0 up
dhclient eth0
echo "auto eth0" >> /etc/network/interfaces
echo "iface eth0 inet dhcp" >> /etc/network/interfaces
```

Can be automated with Ansible role later.

**Group Membership Gotcha:**
After adding user to groups, MUST exit and re-login for groups to activate:
```bash
exit
pct enter <CTID> -- su - root  # Fresh login shell
groups  # Now shows correct groups
```

**MergerFS Requirements:**
- Must run on Proxmox host (not in containers - FUSE limitation)
- Needs `allow_other` option for container access
- Bind mount to containers via `mp0:` in LXC config

### Understanding Gained

**LXC vs VM Differences:**
- VMs: Full cloud-init support, easier hardware passthrough patterns
- LXC: No cloud-init, requires Ansible, lighter weight
- LXC device passthrough requires cgroup rules (manual or Ansible)
- Community scripts favor unprivileged LXC for GPU-only workloads

**Idempotency Patterns:**
Ansible modules designed for safe repeated execution:
- `apt`: Only installs if not present
- `user`/`group`: Creates if missing, no error if exists
- `lineinfile`/`blockinfile`: Only modifies if content different

Makes playbooks safe to run multiple times - key for configuration management.

**State Management Trade-offs:**
- Local state: Simple, fine for single-user homelab
- Remote state (S3): Enables locking, better for teams/learning
- Git-tracked state: Requires encryption, adds complexity
- For homelab: Start local, back up regularly

### Architectural Insights

**Separation of Concerns (Terraform vs Ansible):**
- **Terraform**: Infrastructure provisioning ("what exists")
  - Create containers
  - Allocate resources
  - Configure networking
  - Storage mounts
- **Ansible**: Configuration management ("how it's configured")
  - Install software
  - Configure services
  - Manage files/users
  - Device passthrough (cgroup rules)

Clear boundaries make system easier to reason about and maintain.

**Media User Pattern (Industry Standard):**
Single consistent UID/GID across all services:
- UID 1000 is default first user on Linux (most common)
- Same user = same file ownership everywhere
- No permission conflicts between services
- Automation-friendly (PUID/PGID in Docker)

This pattern used by LinuxServer.io and entire homelab community.

### Tools Comparison

**Why Terraform (not Pulumi):**
- Larger community
- More mature Proxmox support
- Simpler for straightforward use cases
- Pulumi's programming languages overkill for homelab

**Why Ansible (not NixOS):**
- Gentler learning curve
- More documentation for common tasks
- Idempotent modules well-tested
- NixOS interesting but significant investment

**Why BPG Provider (not Telmate):**
- Active maintenance (30+ releases/year)
- Proxmox 8+ support
- Comprehensive feature coverage
- Telmate essentially abandoned

### Security Considerations

**Accepted Trade-offs with Privileged Containers:**
- Root in container = root on host (privilege escalation risk)
- Mitigations: Network segmentation, firewall rules, no internet exposure
- For isolated homelab: Risk acceptable
- Benefits: Simplicity, hardware access, permission reliability

**Secrets Management Approach:**
- Ansible Vault for API tokens, passwords
- Separate vault password file (gitignored)
- Environment variables via direnv
- Never commit plaintext secrets

### Testing Strategy

**Incremental Adoption Pattern:**
1. Test with new container (safe experimentation)
2. Import one production container
3. Verify no changes (`terraform plan` should be clean)
4. Test destroy/recreate workflow
5. Only then migrate remaining containers

Gradual approach prevents breaking production during learning phase.

**Backup Before Destructive Operations:**
- Terraform state backup before every apply
- Proxmox container backup before destroy
- Git commit before major changes
- Can always roll back if something breaks

### Future Enhancements Identified

**Short Term:**
- Automate network interface configuration (Ansible)
- Dynamic inventory from Terraform outputs
- Wrapper scripts for common workflows

**Medium Term:**
- Monitoring (Prometheus/Grafana)
- Automated testing (test containers)
- Health checks in playbooks

**Long Term:**
- Multi-node Proxmox cluster
- Advanced networking (VLANs, SDN)
- CI/CD pipeline (GitHub Actions)
- Full GitOps workflow

### Success Metrics Defined

**After Phase 2 (Test Container):**
- Can destroy/recreate with single command
- Ansible playbook is idempotent
- State tracked in Git
- Understanding of workflow solid

**After Phase 4 (Production Migration):**
- All containers managed by IaC
- Workflows identical to manual setup
- Documentation allows recreation from scratch

**Long Term:**
- Disaster recovery tested successfully
- Configuration changes via Git
- New containers added in minutes
- Confident in maintaining system
